import { Injectable } from '@nestjs/common';
import { CreateResponsibleDto } from './dto/create-responsible.dto';
import { UpdateResponsibleDto } from './dto/update-responsible.dto';
import { InjectRepository } from '@nestjs/typeorm';
import { Responsible } from './entities/responsible.entity';
import { Repository } from 'typeorm';
import { UsersService } from '../users/users.service';
import { MailingService } from '../mailing/mailing.service';

@Injectable()
export class ResponsiblesService {
  constructor(
    @InjectRepository(Responsible)
    private readonly responsibleRepo: Repository<Responsible>,
    private readonly userService: UsersService,
    private readonly mailingService: MailingService,
  ) {}

  async create(createResponsibleDto: CreateResponsibleDto) {
    const randomPassword = this.generateRandomPassword();

    const user = await this.userService.create({
      ...createResponsibleDto,
      password: randomPassword,
    });

    const inviteResponsibleData = {
      name: `${user.name} ${user.surname.split(' ')[0]}`,
      email: user.email,
      password: randomPassword,
    };

    const mailOptions = {
      to: user.email,
      subject: 'Welcome to Qualist',
    };

    this.mailingService.sendMail(
      'responsibleInvite',
      inviteResponsibleData,
      mailOptions,
    );

    return user;
  }

  findAll() {
    return `This action returns all responsibles`;
  }

  findOne(id: number) {
    return `This action returns a #${id} responsible`;
  }

  update(id: number, updateResponsibleDto: UpdateResponsibleDto) {
    return `This action updates a #${id} responsible`;
  }

  remove(id: number) {
    return `This action removes a #${id} responsible`;
  }

  generateRandomPassword = (length = 12): string => {
    const uppercaseLetters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
    const lowercaseLetters = 'abcdefghijklmnopqrstuvwxyz';
    const numbers = '0123456789';
    const specialCharacters = '!@#$%^&*()-_=+[]{}|;:,.<>?';

    const allCharacters =
      uppercaseLetters + lowercaseLetters + numbers + specialCharacters;

    let password = '';

    // Ensure at least one of each character type is included in the password
    password +=
      uppercaseLetters[Math.floor(Math.random() * uppercaseLetters.length)];
    password +=
      lowercaseLetters[Math.floor(Math.random() * lowercaseLetters.length)];
    password += numbers[Math.floor(Math.random() * numbers.length)];
    password +=
      specialCharacters[Math.floor(Math.random() * specialCharacters.length)];

    // Generate the remaining characters randonly
    for (let i = password.length; i < length; i++) {
      password +=
        allCharacters[Math.floor(Math.random() * allCharacters.length)];
    }

    /*
      Shuffle the password to ensure the characters are randomly distributed
      - When the number generated by Math.random() is less than 0.5, the subtraction results in a negative value, indicating that the first element should be sorted before the second.
      - When the number generated by Math.random() is greater than 0.5, the subtraction results in a positive value, indicating that the first element should be sorted after the second.
      - When the number generated by Math.random() is exactly 0.5, the result is zero, indicating that the two elements are considered equal in terms of sorting (although this is rare in practice).
    */
    password = password
      .split('')
      .sort(() => 0.5 - Math.random())
      .join('');

    return password;
  };
}
