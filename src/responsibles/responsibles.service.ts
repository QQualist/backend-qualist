import { Injectable } from '@nestjs/common';
import { CreateResponsibleDto } from './dto/create-responsible.dto';
import { UpdateResponsibleDto } from './dto/update-responsible.dto';
import { UsersService } from '../users/users.service';
import { MailingService } from '../mailing/mailing.service';
import { Repository } from 'typeorm';
import { User } from '../users/entities/user.entity';
import { InjectRepository } from '@nestjs/typeorm';
import { Responsible } from './entities/responsible.entity';

@Injectable()
export class ResponsiblesService {
  constructor(
    @InjectRepository(User)
    private readonly userRepo: Repository<User>,
    private readonly userService: UsersService,
    private readonly mailingService: MailingService,
  ) {}

  async create(createResponsibleDto: CreateResponsibleDto) {
    const randomPassword = this.generateRandomPassword();

    const user = await this.userService.create({
      ...createResponsibleDto,
      password: randomPassword,
    });

    const inviteResponsibleData = {
      name: `${user.name} ${user.surname.split(' ')[0]}`,
      email: user.email,
      password: randomPassword,
    };

    const mailOptions = {
      to: user.email,
      subject: 'Welcome to Qualist',
    };

    this.mailingService.sendMail(
      'responsibleInvite',
      inviteResponsibleData,
      mailOptions,
    );

    return user;
  }

  async findAll(departament_uuid: string) {
    const responsibles: Responsible[] = await this.userRepo.find({
      relations: {
        role: true,
        superior: true,
        type: true,
      },
      where: {
        departament: { uuid: departament_uuid },
      },
    });

    responsibles.forEach(async (responsible) => {
      delete responsible.password; // Remove password from top-level responsible

      // Access the nested superior object and remove password
      if (responsible.superior !== null) {
        delete responsible.superior.password;
      }
    });

    return responsibles;
  }

  findOne(id: number) {
    return `This action returns a #${id} responsible`;
  }

  async update(uuid: string, updateResponsibleDto: UpdateResponsibleDto) {
    return await this.userService.update(uuid, updateResponsibleDto);
  }

  remove(id: number) {
    return `This action removes a #${id} responsible`;
  }

  generateRandomPassword = (length = 12): string => {
    const uppercaseLetters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
    const lowercaseLetters = 'abcdefghijklmnopqrstuvwxyz';
    const numbers = '0123456789';
    const specialCharacters = '!@#$%^&*()-_=+[]{}|;:,.<>?';

    const allCharacters =
      uppercaseLetters + lowercaseLetters + numbers + specialCharacters;

    let password = '';

    // Ensure at least one of each character type is included in the password
    password +=
      uppercaseLetters[Math.floor(Math.random() * uppercaseLetters.length)];
    password +=
      lowercaseLetters[Math.floor(Math.random() * lowercaseLetters.length)];
    password += numbers[Math.floor(Math.random() * numbers.length)];
    password +=
      specialCharacters[Math.floor(Math.random() * specialCharacters.length)];

    // Generate the remaining characters randonly
    for (let i = password.length; i < length; i++) {
      password +=
        allCharacters[Math.floor(Math.random() * allCharacters.length)];
    }

    /*
      Shuffle the password to ensure the characters are randomly distributed
      - When the number generated by Math.random() is less than 0.5, the subtraction results in a negative value, indicating that the first element should be sorted before the second.
      - When the number generated by Math.random() is greater than 0.5, the subtraction results in a positive value, indicating that the first element should be sorted after the second.
      - When the number generated by Math.random() is exactly 0.5, the result is zero, indicating that the two elements are considered equal in terms of sorting (although this is rare in practice).
    */
    password = password
      .split('')
      .sort(() => 0.5 - Math.random())
      .join('');

    return password;
  };
}
